<!--?xml version="1.0" encoding="UTF-8"?-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <title>Hakyll - Tags and manipulations</title>

        <!-- Stylesheets. -->
        <link rel="stylesheet" type="text/css" href="part07_files/default.css">
        <link rel="stylesheet" type="text/css" href="part07_files/syntax.css">

        <!-- Metadata. -->
        <meta name="keywords" content="hakyll,static site generator,static,site,generator,haskell,blog">
        <meta name="description" content="Hakyll - A Static Site Generator in Haskell.">
    </head>
    <body>
        <div id="main">
            <div id="header">
                <img src="part07_files/lambda.png" alt="lambda">
                <h1>Hakyll - Tags and manipulations</h1>
            </div>
            <!-- Sidebar. -->
            <div id="sidebar">
                <div id="navigation"><h2>Navigation</h2><p><a href="http://jaspervdj.be/hakyll/index.html">home</a> <a href="http://jaspervdj.be/hakyll/philosophy.html">philosophy</a> <a href="http://jaspervdj.be/hakyll/about.html">about</a> <a href="http://jaspervdj.be/hakyll/tutorials.html">tutorials</a> <a href="http://jaspervdj.be/hakyll/reference.html">reference</a> <a href="http://jaspervdj.be/hakyll/changelog.html">changelog</a></p></div>
            </div>

            <div id="content">
                <div id="context-manipulations"><h2>Context manipulations</h2><p>Here, have <a href="http://jaspervdj.be/hakyll/examples/tagblog.zip">a zip file</a> for this tutorial.</p><p>You probably remember that <code>Context</code> objects are just key-value mappings. We can render those with templates, and then the <code>$key</code>’s
 in the template get substituted by the appropriate values. This is a 
rather flexible system, but there are limitations. Some of these 
limitations can be solved using <em>context manipulations</em>.</p><p>Like rendering actions, <em>context manipulations</em> are also simply <code>HakyllAction Context Context</code> arrows. The <code>Text.Hakyll.ContextManipulations</code> contains some functions to easily construct easy variants.</p><p>One of the most general functions is the <code>renderValue</code> function. Let’s have a look at it’s type.</p><pre class="sourceCode haskell"><code>renderValue :: <span class="dt">String</span><br>            -&gt; <span class="dt">String</span><br>            -&gt; (<span class="dt">String</span> -&gt; <span class="dt">String</span>)<br>            -&gt; <span class="dt">HakyllAction</span> <span class="dt">Context</span> <span class="dt">Context</span><br></code></pre><p>This is the preferred way of creating context manipulations. The first argument is the <code>key</code> to manipulate. The second argument is the <code>key</code>
 where the new value should be placed. If this is the same as the first 
argument, it will be replaced. The third argument is the function to 
manipulate the <code>value</code> with.</p><p>As a simple example, let’s write a function that puts the <code>$title</code> in uppercase.</p><pre class="sourceCode haskell"><code><span class="kw">import</span> <span class="dt">Data.Char</span> (<span class="fu">toUpper</span>)<br><br>titleUpper :: <span class="dt">HakyllAction</span> <span class="dt">Context</span> <span class="dt">Context</span><br>titleUpper <span class="fu">=</span> renderValue <span class="st">"title"</span> <span class="st">"title"</span> <span class="fu">$</span> <span class="fu">map</span> <span class="fu">toUpper</span><br></code></pre><p>Because the destination <code>key</code> is the same as the source <code>key</code>, we can also use the <code>changeValue</code> function here.</p><pre class="sourceCode haskell"><code>titleUpper <span class="fu">=</span> changeValue <span class="st">"title"</span> <span class="fu">$</span> <span class="fu">map</span> <span class="fu">toUpper</span><br></code></pre><p>For further reading, refer to the <code>Text.Hakyll.ContextManipulations</code> documentation.</p></div><div id="applying-context-manipulations"><h2>Applying Context Manipulations</h2><p>Because we’re dealing with Arrows again, we can use <code>&gt;&gt;&gt;</code> to apply our manipulations. For example, we could use or title manipulation like this:</p><pre class="sourceCode haskell"><code>renderChain [<span class="st">"templates/default.html"</span>]<br>            (createPage <span class="st">"index.markdown"</span> <span class="fu">&gt;&gt;&gt;</span> titleUpper)<br></code></pre></div><div id="rendering-dates"><h2>Rendering dates</h2><p>As you remember, in our previous blog, all posts had a file name like <code>posts/yyyy-mm-dd-title.extension</code>, as is the Hakyll convention. But they also had a metadata field <code>date</code>, containing a human-readable date. This is not very D.R.Y., of course! Hakyll has a specialized <code>renderValue</code> function to deal with dates encoded in paths: <code>renderDate</code>.</p><pre class="sourceCode haskell"><code>postManipulation :: <span class="dt">HakyllAction</span> <span class="dt">Context</span> <span class="dt">Context</span><br>postManipulation <span class="fu">=</span> renderDate <span class="st">"date"</span> <span class="st">"%B %e, %Y"</span> <span class="st">"Unknown date"</span><br></code></pre><p>That manipulation will: - Read the date from the file name the post was loaded from. - Parse the date and render it in a <code>%B %e, %Y</code> format. This is a <code>Month day, Year</code> format. - Put the result in the <code>date</code> metadata field. - If the date could not be parsed, it will put <code>"Unknown date"</code> in the <code>date</code> metadata field.</p><p>So, we can throw away our <code>date:</code> lines from our posts, and still use <code>$date</code> in our templates.</p></div><div id="abstracting-the-post-list"><h2>Abstracting the post list</h2><p>Now,
 we’re going to render tags. This is also done using context 
manipulations. Hakyll has a specialized module to deal with tags, 
provided by <code>Text.Hakyll.Tags</code>. This module assumes tags are comma separated, and placed in the <code>tags</code> metadata field.</p><pre><code>---
title: A third post
author: Publius Ovidius Naso
tags: epic fail, ovidius
---
Pellentesque tempor blandit elit, vel...
</code></pre><p>But first things first. We need to render a post list 
for every tag. We already had some code to render a list of all posts. 
We’re just going to abstract this code into a more general function:</p><pre class="sourceCode haskell"><code>renderPostList url title posts <span class="fu">=</span> <span class="kw">do</span><br>    <span class="kw">let</span> list <span class="fu">=</span> createListingWith url [<span class="st">"templates/postitem.html"</span>]<br>                                 posts [(<span class="st">"title"</span>, <span class="kw">Left</span> title)]<br>    renderChain [<span class="st">"posts.html"</span>, <span class="st">"templates/default.html"</span>] list<br></code></pre><p>Our “render all posts” action can now be written as:</p><pre class="sourceCode haskell"><code>renderPostList <span class="st">"posts.html"</span> <span class="st">"All posts"</span> renderablePosts<br></code></pre></div><div id="tag-links"><h2>Tag links</h2><p>We want to display the tags for our post under the title. But if we use the <code>$tags</code> key in a template, we will just have the plain tags - they will not be clickable. We can again solve this with a <code>ContextManipulation</code>. We have a function that produces an url for a given tag:</p><pre class="sourceCode haskell"><code>tagToUrl tag <span class="fu">=</span> <span class="st">"../tags/"</span> <span class="fu">++</span> removeSpaces tag <span class="fu">++</span> <span class="st">".html"</span><br></code></pre><p><code>removeSpaces</code> is an auxiliary function from <code>Text.Hakyll.File</code>. Now, there is a specialized <code>renderValue</code> function for creating linked tags called <code>renderTagLinks</code>. This function simply takes a function that produces an url for a given tag - the function we just wrote. Let’s extend our <code>postManipulation</code>.</p><pre class="sourceCode haskell"><code>postManipulation :: <span class="dt">HakyllAction</span> <span class="dt">Context</span> <span class="dt">Context</span><br>postManipulation <span class="fu">=</span>   renderDate <span class="st">"date"</span> <span class="st">"%B %e, %Y"</span> <span class="st">"Unknown date"</span><br>                 <span class="fu">&gt;&gt;&gt;</span> renderTagLinks tagToUrl<br></code></pre><p>We apply this manipulation when we load the tags.</p><pre class="sourceCode haskell"><code><span class="kw">let</span> renderablePosts <span class="fu">=</span><br>        <span class="fu">map</span> ((<span class="fu">&gt;&gt;&gt;</span> postManipulation) <span class="fu">.</span> createPage) postPaths<br></code></pre><p>So, the <code>renderTagLinks</code> function replaces the <code>$tags</code> value from <code>epic fail, random</code> to <code>&lt;a href="../tags/epic-fail.html"&gt;epic fail&lt;/a&gt;, ...</code>. If we click a tag, we get a <code>404</code>. That’s because we haven’t generated the post lists for every tag.</p></div><div id="the-tag-map"><h2>The Tag Map</h2><p>Hakyll provides a function called <code>readTagMap</code>. Let’s inspect it’s type.</p><pre class="sourceCode haskell"><code><span class="kw">type</span> <span class="dt">TagMap</span> <span class="fu">=</span> <span class="dt">Map</span> <span class="dt">String</span> [<span class="dt">HakyllAction</span> () <span class="dt">Context</span>]<br>readTagMap <span class="dt">String</span> [<span class="fu">FilePath</span>] -&gt; <span class="dt">HakyllAction</span> () <span class="dt">TagMap</span><br></code></pre><p>You
 give it a list of paths, and it creates a map that, for every tag, 
holds a number of posts. We can easily use this to render a post list 
for every tag. The first argument given is an “identifier”, unique to 
this tag map. Hakyll needs this so it can cache the tags.</p><pre class="sourceCode haskell"><code><span class="kw">let</span> tagMap <span class="fu">=</span> readTagMap <span class="st">"postTags"</span> postPaths<br></code></pre><p>When we have the <code>TagMap</code>, we can need to render a post list for every tag. There is a function in Hakyll designed more or less for this purpose: <code>withTagMap</code>. This takes a <code>TagMap</code> and an action to execute for every tag and it’s associated posts. We pass a small function to it we create ourselves<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup>:</p><pre class="sourceCode haskell"><code><span class="kw">let</span> renderListForTag tag posts <span class="fu">=</span><br>        renderPostList (tagToUrl tag)<br>                       (<span class="st">"Posts tagged "</span> <span class="fu">++</span> tag)<br>                       (<span class="fu">map</span> (<span class="fu">&gt;&gt;&gt;</span> postManipulation) posts)<br>withTagMap tagMap renderPostList<br></code></pre><p>There we go. We now have clickable tags, and a post list for every tag.</p></div><div id="a-tag-cloud"><h2>A Tag Cloud</h2><p>A tag cloud is a commonly found thing on blogs. Hakyll also provides code to generate a tag cloud. Let’s have a look at the <code>renderTagCloud</code> function.</p><pre class="sourceCode haskell"><code>renderTagCloud :: (<span class="dt">String</span> -&gt; <span class="dt">String</span>)<br>               -&gt; <span class="dt">Float</span><br>               -&gt; <span class="dt">Float</span><br>               -&gt; <span class="dt">HakyllAction</span> <span class="dt">TagMap</span> <span class="dt">String</span><br></code></pre><p>The
 first argument is, once again, a function to create an url for a given 
tag. Then, we give a minimum and a maximum font size in percent, and we 
get a tag cloud Arrow back. We can add this to our index:</p><pre class="sourceCode haskell"><code><span class="kw">let</span> tagCloud <span class="fu">=</span> tagMap <span class="fu">&gt;&gt;&gt;</span> renderTagCloud tagToUrl <span class="dv">100</span> <span class="dv">200</span><br>    <span class="fu">index</span> <span class="fu">=</span> createListing <span class="st">"index.html"</span><br>                          [<span class="st">"templates/postitem.html"</span>]<br>                          (<span class="fu">take</span> <span class="dv">3</span> renderablePosts)<br>                          [ (<span class="st">"title"</span>, <span class="kw">Left</span> <span class="st">"Home"</span>)<br>                          , (<span class="st">"tagcloud"</span>, <span class="kw">Right</span> tagCloud)<br>                          ]<br>renderChain [<span class="st">"index.html"</span>, <span class="st">"templates/default.html"</span>] <span class="fu">index</span><br></code></pre></div><div id="the-gist-of-it"><h2>The gist of it</h2><ul><li>There’s some handy, simple functions in <code>Text.Hakyll.ContextManipulations</code>.</li><li>Seperate tags by commas and put them in the <code>$tags</code> field.</li><li>Use <code>withTagMap</code> to render a list for every tag.</li><li>Hakyll can also create tag clouds.</li></ul></div><div class="footnotes"><hr><ol><li id="fn1"><p>Exercise for the reader: why do we use <code>&gt;&gt;&gt; postManipulation</code> again here? <a href="#fnref1" class="footnoteBackLink" title="Jump back to footnote 1">↩</a></p></li></ol></div>

<h2>Helping out</h2>

Hakyll is an open source project, and one of the hardest parts is writing
correct, up-to-date, and understandable documentation. Therefore, the
authors would really appreciate it if you would
<a href="http://groups.google.com/group/hakyll">give some feedback</a> about
the tutorials, and especially report errors or difficulties you encountered.
Thanks!

            </div>

            <div id="footer">
                Site proudly generated by <a href="http://github.com/jaspervdj/hakyll">hakyll</a>.
            </div>
        </div>

        <!-- Google Analytics -->
        <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
        </script><script src="part07_files/ga.js" type="text/javascript"></script>
        <script type="text/javascript">
            try {
                var pageTracker = _gat._getTracker("UA-11993001-1");
                pageTracker._trackPageview();
            } catch(err) {}
        </script>
    


</body></html>