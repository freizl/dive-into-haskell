#+title: thinking with types

* Chapter 0
- typed function ~printf~ (in [[id:e0925dd0-0dd1-4961-9398-f31a07aa5272][Chapter 9]])
* Chapter 1 Algebra data type
- cardinality:
  #+BEGIN_QUOTE
  the number of inhabitants it has, ignoring bottoms.
  #+END_QUOTE
  - or can we say /number of data constructor/? not really.
    #+BEGIN_SRC
    card{Maybe a} = 1 + card{a}
    where 1 comes from Nothing
    #+END_SRC
  - *inhabitants*
- isomorphic: types have same cardinality always be ~iso~
- cardinality of function
  #+BEGIN_SRC
    card{a -> b} = card{b}^card{a}
  #+END_SRC
  #+BEGIN_QUOTE
  In fact, even the notion of differentiation in calculus has meaning in the domain of types.
  Conor McBride's paper The Derivative of a Regular Type is its Type of One-Hole Contexts.
  #+END_QUOTE
- The Curry--Howard Isomorphism
  - TODO: import that table
- proof that ~(a^b)^c = a^(b*c)~
  #+BEGIN_SRC haskell
  fn1 = b -> c -> a
  fn2 = (b, c) -> a
  curry = fn2 -> fn1
  uncurry = fn1 -> fn2
  #+END_SRC
- proof that ~a^b * a^c = a^(b+c)~
  #+BEGIN_SRC haskell
  data1 = (b -> a, c -> a)
  fn1 :: Either b c -> a
  to :: (b->a, c->a) -> (Either b c -> a)
  to (f, g) (Left b)  = f b
  to (f, g) (Right c) = g c
  from :: (Either b c -> a) -> (b->a, c->a)
  from fx = (f, g)
            where f b = fx (Left b)
                  g c = fx (Right c)
  #+END_SRC
- proof that ~(a*b)^c = a^c * b^c~
  #+BEGIN_SRC haskell
  fn1 :: c -> (a, b)
  data1 = (c -> a, c -> b)
  to :: (c -> (a, b)) -> (c->a, c->b)
  to fx = (fst . fx, snd . fx)
  from :: (c->a, c->b) -> (c -> (a, b))
  from (f, g) c = (f c, g c)
  #+END_SRC
- ~ghc.generics~, canonical forms
  - [ ] did not understand
  - more on [[id:b7df2fab-22ab-4af9-a6f9-8c830699fde8][Chapter 13]]
* Chapter 2 Terms, Types, Kinds
- Kind
  #+BEGIN_SRC haskell
  :k Maybe
  Maybe :: * -> *
  :k (->)
  (->) :: * -> * -> *
  :k Either
  Either :: * -> * -> *
  #+END_SRC

- ~*~ is slated for deprecation
- type class returns ~Constraint~ at type level
  #+BEGIN_SRC haskell
  Show :: * -> Constraint
  Functor :: (* -> *) -> Constraint
  Monad :: (* ->*) -> Constraint
  #+END_SRC
- *esoteric* language extensions
- ~DataKinds~ extension
  #+BEGIN_SRC haskell
  {-# LANGUAGE DataKinds     #-}
  data Bool = True | False
  {-
    type constructor Bool,  kind *
    data constructor True,  type Bool
    data constructor False, type Bool
    a new kind: Bool
    promoted data constructor 'True,  kind Bool
    promoted data constructor 'False, kind Bool
  -}
  #+END_SRC
- promoted data constructors exist in the same name-space as type constructors
- all built data constructor can be promoted by ~DataKinds~
  - need to understand deep on the motivation, benefits, use cases.
  - seems pretty tricky when dealing with promoted data con of List, Tuple
- closed type family
  - functions at the type level
  - ~TypeFamilies~
  - Can read as /define a type function Or that../ ?
    #+BEGIN_SRC haskell
    type family Or (x :: Bool) (y :: Bool) :: Bool where
    Or 'True  y = 'True
    Or 'False y = y
    #+END_SRC
  - type families must be *saturated*. no currying.
    - work around by *first class families* in [[id:b1d99df8-7efd-4211-95e9-ee721da577c5][Chapter 10]]
* Chapter 3 Variance
- covariant
  - ~BiFunctor~
- contravariant
  - [[https://hackage.haskell.org/package/contravariant][hackage contravariant]]
  - ~CoFunctor~
  - ~ProFunctor~
  - ~contramap :: (a -> b) -> f b -> f a~
  - what hack / usefulness is this?
- invariant
  - [[https://hackage.haskell.org/package/invariant][hackage invariant]]
  - /invariant type allows you to map from a to b iff a and b are iso/
- [ ] Don't understand nor the Positive and Negative of types.
* Chapter 4 Working with types
1. ~ScopeTypeVariables~
   + works with explicit ~forall~ quantifier
   + ~forall~ introduces a type scope
2. ~TypeApplications~
   + directly apply types to expressions
   + ~fmap @Maybe :: (a->b) -> Maybe a -> Maybe b~
   + ~:t fmap @_ @Int @Bool :: Functor w => (Int->Bool) -> w Int -> w Bool~
* Chapter 5 Contstraints and GADTs
1. type class Constraints :: left side of fat arrow ~=>~
2. type equalities: the ~a ~ Int~ in ~five :: (a ~ Int) => a~
3. GADT is syntactic sugar over type equalities.
4. heterogeneous list :: a list that can store values of different types
5. [ ] need to dig deeper into heterogeneous list implementation
* Chapter 6 Rank-N Types
1. can not compile
   #+BEGIN_SRC haskell
applyToFive :: (a -> a) -> Int
applyToFive f = f 5
   #+END_SRC
2. ~RankNTypes~ :: polymorphism anywhere but not top level
3. What is ~rank~? /depth/ or /level/ of the polymorphism of a function
4. rank 0 mean no polymorphism
5. rank 1, e.g. ~a -> a~, ~[a] -> a~
6. [ ] is there way to check the rank of a function?
7. ~applyToFive~ is rank 2
8. call it ~rank-n~ when above rank-1
9. why higher-rank types? functions which takes /callbacks/.
10. CPS, ~Cont~ data type v.s. nested callback
* Chapter 7 Existential Types
1. ~data Any = forall a. Any a~
2. can also be represented using GADT
3. Generalized Constraint
   #+BEGIN_SRC haskell
data Has (c :: Type -> Constraint) where
  Has :: c t => t -> Has c

type HasShow = Has Show
-- compares to
data HasShow where
  HasShow :: Show t => t -> HasShow

type Dynamic = Has Typeable
-- comparse to
data Dynamic where
  Dynamic :: Typeable t => t -> Dynamic

   #+END_SRC
4. What is ~Type~ and ~Constraint~
   - from [[http://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Kind.html][Data.Kind]]
    
   #+BEGIN_QUOTE
type Type = Type
The kind of types with lifted values. For example Int :: Type.

data Constraint
The kind of constraints, like Show a
   #+END_QUOTE

* Chapter 8 Roles
- ~newtype~ is zero cost
- ~coerce :: Coercible a b => a -> b~
  + as long as ~a~ and ~b~ have same runtime representation.
- type has been assigned to role, and there are 3 roles
  + nominal
  + representational
  + phantom
* Chapter 9 Associated Type Families
* Chapter 10
* Chapter 11
* Chapter 12
* Chapter 13
* Chapter 14
* Chapter 15
* Questions [0/2]
- [ ] what is ~Data.Proxy~?
- [ ] check ~bifunctor~, ~profunctor~ from <The Monad Book>
