<!--?xml version="1.0" encoding="UTF-8"?-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <title>Hakyll - Creating a Blog</title>

        <!-- Stylesheets. -->
        <link rel="stylesheet" type="text/css" href="part05_files/default.css">
        <link rel="stylesheet" type="text/css" href="part05_files/syntax.css">

        <!-- Metadata. -->
        <meta name="keywords" content="hakyll,static site generator,static,site,generator,haskell,blog">
        <meta name="description" content="Hakyll - A Static Site Generator in Haskell.">
    </head>
    <body>
        <div id="main">
            <div id="header">
                <img src="part05_files/lambda.png" alt="lambda">
                <h1>Hakyll - Creating a Blog</h1>
            </div>
            <!-- Sidebar. -->
            <div id="sidebar">
                <div id="navigation"><h2>Navigation</h2><p><a href="http://jaspervdj.be/hakyll/index.html">home</a> <a href="http://jaspervdj.be/hakyll/philosophy.html">philosophy</a> <a href="http://jaspervdj.be/hakyll/about.html">about</a> <a href="http://jaspervdj.be/hakyll/tutorials.html">tutorials</a> <a href="http://jaspervdj.be/hakyll/reference.html">reference</a> <a href="http://jaspervdj.be/hakyll/changelog.html">changelog</a></p></div>
            </div>

            <div id="content">
                <div id="creating-a-simple-blog-with-hakyll"><h2>Creating a simple blog with Hakyll</h2><p>After
 we created a simple brochure site, we’re going to try something more 
advanced: we are going to create a simple blog system.</p><p>A <a href="http://jaspervdj.be/hakyll/examples/simpleblog.zip">zip file</a> containing the source for this tutorial is also available.</p><p>Blogs,
 as you probably know, are composed of posts. In Hakyll, we’re going to 
use simple pages for posts. All posts are located in the <code>posts</code> directory. But we’re not going to use the <code>directory</code> command here - you will see why later. First, some trivial things like css.</p><pre class="sourceCode haskell"><code>main <span class="fu">=</span> hakyll <span class="st">"http://example.com"</span> <span class="fu">$</span> <span class="kw">do</span><br>    directory css <span class="st">"css"</span><br></code></pre></div><div id="finding-the-posts"><h2>Finding the posts</h2><p><code>Text.Hakyll.File</code> contains a handy function <code>getRecursiveContents</code>, which will provide us with all the blog posts. The blog posts have a <code>yyyy-mm-dd-title.extension</code>
 naming scheme. This is just a simple trick so we can sort them easily 
(sorting on filename implies sorting on date). You could of course name 
them whatever you want, but it’s always a good idea to stick to the 
conventions. They contain some metadata, too:</p><pre><code>title: A first post
author: Julius Caesar
date: November 5, 2009
---
Lorem ipsum dolor sit amet, consectetur adipiscing elit. 
Vivamus pretium leo adipiscing lectus iaculis lobortis.
Vivamus scelerisque velit dignissim metus...
</code></pre><p>Now, we find the posts and sort them reversed, so the most recent post will become the first item in the list:</p><pre class="sourceCode haskell"><code>postPaths &lt;- liftM (<span class="fu">reverse</span> <span class="fu">.</span> <span class="fu">sort</span>) <span class="fu">$</span> getRecursiveContents <span class="st">"posts"</span><br></code></pre><p>Our <code>postPaths</code> value is now of the type <code>[FilePath]</code>. We want to be able to render all posts, so we pass them to the <code>createPage</code> function.</p><pre class="sourceCode haskell"><code><span class="kw">let</span> postPages <span class="fu">=</span> <span class="fu">map</span> createPage postPaths<br></code></pre><p>We have two templates we want to render our posts with: first we would like to render them using <code>templates/post.html</code>, and we want to render the result using <code>templates/default.html</code>. This can be done with the <code>renderChain</code> function:</p><pre class="sourceCode haskell"><code><span class="fu">mapM_</span> (renderChain [ <span class="st">"templates/post.html"</span><br>                   , <span class="st">"templates/default.html"</span><br>                   ]) postPages<br></code></pre><p>Remember that the <code>renderChain</code> works by rendering the item using the first template, creating a new page with the render result in the <code>$body</code> field, and so on until it has been rendered with all templates.</p><p>Now,
 we have the posts rendered. What is left is to generate some kind of 
index page with links to those posts. We want one general list showing 
all posts, and we want to show a few recent posts on the index page.</p></div><div id="creating-listings."><h2>Creating listings.</h2><p><code>createPage</code> is the easiest way of reading a <code>Context</code>. But in this case, we want something more custom, so we’ll use the <code>createCustomPage</code> function. This allows us to create a more specific <code>Context</code>.</p><pre class="sourceCode haskell"><code>createCustomPage :: <span class="fu">FilePath</span><br>                 -&gt; [(<span class="dt">String</span>, <span class="dt">Either</span> <span class="dt">String</span> (<span class="dt">HakyllAction</span> () <span class="dt">String</span>))]<br>                 -&gt; <span class="dt">HakyllAction</span> () <span class="dt">Context</span><br></code></pre><p>The first argument is the <code>url</code> of the page to generate. For our index page, this will be, <code>index.html</code>. The second argument is obviously our <code>key: value</code> mapping. But why the <code>Either</code>? This, once again, is about dependency handling. The idea is that you can choose which type to use for the value:</p><ul><li><code>String</code>: Simply a <code>String</code>.</li><li><code>HakyllAction () String</code>: Here, you can give an <code>HakyllAction</code> Arrow action that can produce a String. However - this action <em>will not be executed</em> when the file in <code>_site</code> is up-to-date.</li></ul><p>However, in this specific case - a list of posts - there is an easier, and more high-level approach than <code>createCustomPage</code><sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup>. Let’s look at the type signature of <code>createListing</code>:</p><pre class="sourceCode haskell"><code>createListing :: <span class="fu">FilePath</span><br>              -&gt; [<span class="fu">FilePath</span>]<br>              -&gt; [<span class="dt">HakyllAction</span> () <span class="dt">Context</span>]<br>              -&gt; [(<span class="dt">String</span>, <span class="dt">Either</span> <span class="dt">String</span> (<span class="dt">HakyllAction</span> () <span class="dt">String</span>))]<br>              -&gt; <span class="dt">HakyllAction</span> () <span class="dt">Context</span><br></code></pre><p>The first argument is the destination url. For our blog, this is of course <code>index.html</code>. The second argument is a list templates to render <em>each</em> <code>Context</code> with. We use only <code>templates/postitem.html</code> here. This is, as you can see, a simple template:</p><pre class="sourceCode html"><code><span class="kw">&lt;li&gt;</span><br>    <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">"$root/$url"</span><span class="kw">&gt;</span>$title<span class="kw">&lt;/a&gt;</span><br>    - <span class="kw">&lt;em&gt;</span>$date<span class="kw">&lt;/em&gt;</span> - by <span class="kw">&lt;em&gt;</span>$author<span class="kw">&lt;/em&gt;</span><br><span class="kw">&lt;/li&gt;</span><br></code></pre><p>We then give a list of <code>Context</code>s to render. For our index, these are the 3 last posts. The last argument of the <code>createListing</code> functions lets you specify additional key-value pairs, like in <code>createCustomPage</code>. We use this to set the title of our page. So, we create our index page using:</p><pre class="sourceCode haskell"><code><span class="kw">let</span> <span class="fu">index</span> <span class="fu">=</span> createListing <span class="st">"index.html"</span><br>                          [<span class="st">"templates/postitem.html"</span>]<br>                          (<span class="fu">take</span> <span class="dv">3</span> postPages)<br>                          [(<span class="st">"title"</span>, <span class="kw">Left</span> <span class="st">"Home"</span>)]<br></code></pre><p>The result of this will be a <code>HakyllAction () Context</code>. This <code>Context</code>’s <code>$body</code> will contain a concatenation of all the 3 posts, rendered with the <code>templates/postitem.html</code> template.</p><p>Now, we only have to render it: first using the <code>index.html</code> template - which adds some more information to our index - then using the <code>templates/default.html</code> template.</p><pre class="sourceCode haskell"><code>renderChain [<span class="st">"index.html"</span>, <span class="st">"templates/default.html"</span>] <span class="fu">index</span><br></code></pre><p>Note that the <code>index.html</code> in the <code>renderChain</code> list is also a template. Now, you might want to take your time to read the <code>index.html</code> template and the other files in the zip so you understand what is going on here.</p></div><div id="the-gist-of-it"><h2>The gist of it</h2><ul><li>You can find blogposts using <code>getRecursiveContents</code>.</li><li>The convention is to call them <code>yyyy-mm-dd-rest-of-title.extension</code>. This allows us to sort them easily.</li><li>You can use <code>createCustomPage</code> or <code>createListing</code> to create custom pages and simple listings.</li></ul></div><div class="footnotes"><hr><ol><li id="fn1"><p>Since Hakyll–1.3 onwards. <a href="#fnref1" class="footnoteBackLink" title="Jump back to footnote 1">↩</a></p></li></ol></div>

<h2>Helping out</h2>

Hakyll is an open source project, and one of the hardest parts is writing
correct, up-to-date, and understandable documentation. Therefore, the
authors would really appreciate it if you would
<a href="http://groups.google.com/group/hakyll">give some feedback</a> about
the tutorials, and especially report errors or difficulties you encountered.
Thanks!

            </div>

            <div id="footer">
                Site proudly generated by <a href="http://github.com/jaspervdj/hakyll">hakyll</a>.
            </div>
        </div>

        <!-- Google Analytics -->
        <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
        </script><script src="part05_files/ga.js" type="text/javascript"></script>
        <script type="text/javascript">
            try {
                var pageTracker = _gat._getTracker("UA-11993001-1");
                pageTracker._trackPageview();
            } catch(err) {}
        </script>
    


</body></html>